<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Remember It Wholesale</title>
    <base href="/" />
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1" />
    <link rel="icon" href="./assets/favicon/favicon-32.png" sizes="32x32" />
    <link rel="manifest" href="./assets/favicon/manifest.webmanifest" />
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/marked/lib/marked.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/date-fns/cdn.min.js"></script>
    
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs/dist/cdn.min.js"></script>
    <style>
      :root {
        --primary-color: #5EEAD4;
        --surface-ground: #040D19;
      }
      
      * {
        font-family: 'Noto Sans', sans-serif !important;
      }
      
      html, body {
        background-color: black;
        color: white;
        padding: 0;
        margin: 0;
        width: 100%;
        height: 100%;
      }
      
      body {
        overflow-y: scroll;
        overflow-x: hidden;
      }
      
      a {
        color: #9499CC;
      }
      
      a:visited {
        color: #D0ADF0;
      }
      
      .main-wrap {
        padding: 15px;
      }

      .panel-wrap {
        padding: 20px;
        border-radius: 40px;
        background-color: var(--surface-ground);
        outline: 2px dashed var(--primary-color);
        max-width: 100%;
        word-wrap: break-word;
      }
      
      .header {
        width: 100%;
        box-sizing: border-box;
        padding: 15px 15px 15px 20px;
        font-size: 120%;
        font-weight: bold;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border: 1px solid var(--primary-color);
        background: linear-gradient(90deg, rgb(0, 0, 0) 10%, var(--primary-color) 100%);
      }
      
      .left {
        display: flex;
        align-items: center;
      }

      .left .header-sub {
        font-size: 85%;
        font-weight: normal;
      }

      .right {
        display: flex;
        align-items: center;
      }
      
      .smaller-text {
        font-size: 80%;
      }

      .main-error, .main-error i {
        font-size: 170%;
      }

      .main-error {
        padding-top: 10%;
        text-align: center;
        font-weight: bold;
      }

      .main-error i {
        color: red;
      }

      .main-error .smaller {
        font-size: 80%;
        font-weight: normal;
      }
      
      .icon-button {
        cursor: pointer;
      }
      
      .icon-button:hover {
        filter: drop-shadow(0 0 5px white);
      }
      
      .show-on-mobile {
        display: none;
      }
      
      .show-on-desktop {
        display: inline-block;
      }
      
      .scroll-top-button {
        position: fixed;
        z-index: 20;
        bottom: 0;
        right: 0;
        cursor: n-resize;
        font-size: 32px;
      }
      
      .giw { /* Gallery image wrapper */
        /* TTODO Tweaks
         - Set max-width: 15% instead of width to avoid horizontal square
         - Set max-height: 25vh and remove line-height to avoid vertical square
         - Change width to higher/lower percent to do a diferent grid size
         - For mobile probably do max-width: 50% and call it a day
        */
        display: inline-block;
        vertical-align: middle;
        text-align: center;
        width: 25%;
        height: 25vh;
        line-height: 25vh;
        cursor: zoom-in;
      }
      
      .giw img {
        border-radius: 5px;
        box-shadow: 0 0 5px #666666;
        max-width: 100%;
        max-height: 25vh;
        vertical-align: middle;
        position: relative;
        /* TTODO Tweaks - Make transition toggleable (or don't use it) as it can be quite jarring to mouse around the page
        transition: transform 100ms linear; */
      }
      
      .giw:hover {
        position: relative;
        z-index: 5;
      }
      
      .giw:hover img {
        box-shadow: 0 0 20px #666666;
        outline: 1px solid black;
      }
      
      @media (max-width: 850px) { /* var(--mobile-breakpoint) equivalent, just can't use in media queries */
        .show-on-mobile {
          display: inline-block;
        }
        
        .show-on-desktop {
          display: none;
        }
        
        .header {
          padding: 5px 10px 5px 10px;
        }
      
        .main-wrap {
          padding: 0;
        }
        
        .panel-wrap {
          padding: 10px;
          border-radius: 0;
          outline: 0;
        }
      }
    </style>
  </head>
  <body x-data="state"
        x-init="Alpine.nextTick(() => { bodyReady = true })"
        style="display: none;" x-show="bodyReady" x-transition.opacity x-transition.duration.750ms>
    <div x-show="!loading" class="header"
         x-bind:style="thing && { border: `1px solid ${thing.color}`, background: `linear-gradient(90deg, rgb(0, 0, 0) 10%, ${thing.color} 100%)` }">
      <div class="left">
        <template x-if="thing">
          <div>
            <span x-text="thing.name"></span>
            <span class="show-on-desktop">&nbsp;-</span>
            <br class="show-on-mobile"/>
            <span class="header-sub">
              <span class="show-on-desktop">Updated</span>
              <span x-text="getUpdated(thing, !isMobileSize())"></span>
            </span>
            <span class="show-on-desktop">|&nbsp;</span>
          </div>
        </template>
        <span class="show-on-desktop">Remember It Wholesale</span>
      </div>
      <div class="right icon-button" @click="location.href = 'login'" title="Login to the main app">
        üîí
      </div>
    </div>
    <!-- TTODO Loading indicator <p-progressBar [mode]="loading ? 'indeterminate' : 'determinate'" class="loading-bar" /> -->
      
    <template x-if="invalidLink">
      <div class="main-error">
        <i class="pi pi-exclamation-triangle"></i>
        <br/>
        Failed to load public link<br/>
        <span class="smaller">Contact whoever gave it to you</span>
      </div>
    </template>
    <template x-if="!invalidLink && !loading">
      <div class="main-wrap">
        <div class="panel-wrap">
          <template x-if="isValidString(thing?.fieldsAsString)">
            <span x-html="thing?.fieldsAsString"></span>
          </template>
          
          <template x-if="hasUploads()">
            <div style="text-align: center;">
              <br/>
              <template x-for="upload in thing.uploads">
                <div class="giw"
                     x-data="{ scale: 1 }"
                     @click="scale += 0.5"
                     @contextmenu.prevent="scale = Math.max(scale-0.5, 1.75)"
                     @mouseover="scale = 1.75"
                     @mouseout="scale = 1">
                  <template x-if="upload.type === 'title'">
                    <span>
                      Attached File:
                      <a :href="upload.url" target="_blank"
                        x-text="upload.name"></a>
                      <span x-text="`(size ${readableSize(upload.size)})`" class="smaller-text"></span>
                    </span>
                  </template>
                  <template x-if="upload.type === 'image'">
                    <!-- TTODO Because the page height is 0 while loading, lazy considers ALL images to be in view, so they all load at once
                               Realistically we need to stagger these somehow, so that as the first page full loads the rest are lazy for later -->
                    <img loading="lazy" :alt="upload.name" :src="upload.url"
                         :title="`${upload.name} (size ${readableSize(upload.size)})`"
                         :style="'transform: scale(' + scale + ')'"/>
                  </template>
                </div>
              </template>
            </div>
          </template>
          
          <template x-if="!hasUploads() && !isValidString(thing?.fieldsAsString)">
            <span>No additional content is provided</span>
          </template>
        </div>
      </div>
    </template>
    
    <div @click="window.scrollTo({ top: 0, behavior: 'smooth'})"
         @scroll.window.throttle.100ms="showScrollTop = document.documentElement.scrollTop/document.documentElement.scrollHeight >= 0.20;"
         x-show="showScrollTop" x-transition.opacity x-transition.duration.500ms
         class="scroll-top-button">
      üîù
    </div>
  </body>
  <script>
    const PUBLIC_THING_PARAM = 't';
    const PUBLIC_USER_PARAM = 'u';
    const BACKEND_API = `${window.location.protocol}//${window.location.hostname}:4333`;
    
    var state = {
      bodyReady: false,
      showScrollTop: false,
      loading: false,
      invalidLink: false,
      thing: null,
    }
    
    function main() {
      document.addEventListener('alpine:initialized', () => {
        state = Alpine.reactive(state);
        
        const queryParams = new URLSearchParams(window.location.search);
        const toLoadId = queryParams && isValidString(queryParams.get(PUBLIC_THING_PARAM)) ? queryParams.get(PUBLIC_THING_PARAM) : null;
        const username = queryParams && isValidString(queryParams.get(PUBLIC_USER_PARAM)) ? queryParams.get(PUBLIC_USER_PARAM) : null;
        if (toLoadId && username) {
          loadPublicThing(toLoadId, username).then(res => {
            console.log("Load link results", res);
            state.thing = res;
            state.thing.fieldsAsString = convertFieldsToString();
            
            // Update our page title
            document.title = state.thing.name + ' - RIW';
            
            // Apply our base URL to the path provided by any uploaded file
            if (hasUploads()) {
              state.thing.uploads.forEach(upload => {
                if (upload && upload.url) {
                  upload.url = `${BACKEND_API}/${upload.url}`;
                }
              });
              
              // Sort with non-images first
              state.thing.uploads.sort((a, b) => {
                if (a.type === 'title' && b.type !== 'title') {
                  return -1;
                } else if (a.type !== 'title' && b.type === 'title') {
                  return 1;
                } else {
                  return 0;
                }
              });
            }
          }).catch(err => {
            state.invalidLink = true;
            console.error("Failed to load link", err);
          });
        }
        else {
          state.invalidLink = true;
        }
      });
    }
    main();
    
    async function _fetchWithLoading(url, body) {
      state.loading = true;
      try {
        const options = {
          method: 'GET'
        };
        if (body) {
          options.body = body;
        }
        
        const response = await fetch(url, options);
        if (response.ok) {
          return response.json();
        }
        
        throw new Error(response.status + ": " + response.statusText);
      }catch (error) {
        throw error;
      }finally {
        state.loading = false;
      }
    }
    
    async function loadPublicThing(thingId, username) {
      return _fetchWithLoading(
        `${BACKEND_API}/pthing/${thingId}?username=${username}`
      );
    }
    
    function getUpdated(thing, longForm) {
      if (thing) {
        let toReturn = dateFns.formatDistanceStrict(thing.updated, new Date(), { addSuffix: true });
        
        // If we're at "seconds", just return simple text instead
        if (toReturn.indexOf('second') !== -1) {
          return 'New';
        }
        
        if (!longForm) {
          // Otherwise shorthand format
          toReturn = toReturn.replace(' minute', 'm');
          toReturn = toReturn.replace(' hour', 'h');
          toReturn = toReturn.replace(' day', 'd');
          toReturn = toReturn.replace(' month', 'mon');
          toReturn = toReturn.replace(' year', 'y');
        
          // Then remove any plural leftovers
          toReturn = toReturn.replace('s', '');
        }
        
        return toReturn;
      }
      return '?';
    }
    
    // Utility functions
    function isMobileSize() {
      return window.matchMedia("(max-width: 850px)").matches;
    }    
    
    function isValidString(str) {
      return !!(str && typeof str === 'string' && str.trim().length > 0);
    }
    
    function readableSize(size) {
      const i = size == 0 ? 0 : Math.floor(Math.log(size) / Math.log(1024));
      return +((size / Math.pow(1024, i)).toFixed(2)) * 1 + ' ' + ['B', 'kB', 'MB', 'GB', 'TB'][i];
    }
    
    function hasUploads() {
      return state && state.thing && state.thing.uploads &&
             Array.isArray(state.thing.uploads) &&
             state.thing.uploads.length > 0;
    }
    
    function anchorUrlsInText(text) {
      const urlRegex = /(\b(https?):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
      return text.replace(urlRegex, url => {
        return '<a href="' + url + '" target="_blank">' + url + '</a>';
      });
    }
    
    function convertFieldsToString() {
      // TODO Determine a way to share the convertFieldsToString between main Angular code (in thing.ts) and public Alpine code here
      if (state.thing && state.thing.fields &&
          Array.isArray(state.thing.fields) &&
          state.thing.fields.length > 0) {
        // Some tough choices overall on how to display the custom fields in a usable way
        let toReturn = state.thing.fields.map((field) => {
          if (typeof field.value !== 'undefined' && field.value !== null) {
            let textLabel = null;
            // Special case just for Notes, where we don't need a header
            if (field.label === 'Notes' &&
                state.thing.length === 1 &&
                field.type === 'textarea') {
              textLabel = '';
            }
            else {
              // If our label ends with a question mark, don't put a colon
              let suffix = field.label?.endsWith('?') ? ' ' : ': ';
              
              // If the field is a text area, use a breakline so it's more like a header
              let useBreakline = false;
              if (field.type === 'textarea') {
                suffix = '';
                useBreakline = true;
              }
              
              textLabel = '<b>' + field?.label + '</b>' + suffix +
                          (useBreakline ? '<br/>' : '');
            }
            
            // If we're a Markdown type, convert to HTML
            let textValue = field.value + '';
            if (field.type === 'markdown') {
              textValue = marked.parse(textValue);
            }
            // If we're a plain string replace any \n and \t, such as textareas, so they maintain their formatting
            // Don't do this for Markdown as we already have converted it
            else if (typeof field.value === 'string') {
              textValue = textValue.replaceAll("\n", "<br/>");
              textValue = textValue.replaceAll("\t", "    ");
            }
            
            // Convert our boolean to Yes/No for readability
            if (typeof field.value === 'boolean') {
              textValue = field.value ? 'Yes' : 'No';
            }
            // Check for any links and automatically parse them to clickable versions
            // Except, again, for Markdown, which does it automatically
            else if (field.type !== 'markdown') {
              textValue = anchorUrlsInText(textValue);
            }
            
            // Since we can't rely on Angular's built in XSS prevention, we need to use DOMPurify to do so
            // Allow 'target' for our links to open in a _blank new window
            textValue = DOMPurify.sanitize(textValue, { ADD_ATTR: ['target'] });
            
            return textLabel + textValue;
          }
          return null;
        }).filter(Boolean).join('<br/>'); // Strip empty results and add a breakline
        
        return toReturn;
      }
      return '';
    }
  </script>
</html>